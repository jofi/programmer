{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mat\u00fa\u0161ova \u0161kola programovania Vitaj Mat\u00fa\u0161ko! Prostredn\u00edctvom t\u00fdchto str\u00e1nok by som Ti chcel pom\u00f4c\u0165 nau\u010di\u0165 sa programova\u0165. Z\u00e1merne som si vybral tento sp\u00f4sob, preto\u017ee umo\u017e\u0148uje postupne prid\u00e1va\u0165 nov\u00e9 lekcie, pr\u00edklady sa daj\u00fa uk\u00e1za\u0165 vo viacer\u00fdch programovac\u00edch jazykoch, umo\u017e\u0148uje aj in\u00fdm osob\u00e1m (napr. Jo\u017ekovi) prid\u00e1va\u0165 nov\u00e9 materi\u00e1ly (alebo opravova\u0165 star\u00e9 chyby) ...ktovie \u010do v\u0161etko e\u0161te... Ako sa tu orientova\u0165? Jednoducho! V\u013eavo je jednoduch\u00e9 naviga\u010dn\u00e9 menu. M\u00f4\u017ee\u0161 ho vn\u00edma\u0165 ako odkazy na jednotliv\u00e9 lekcie. Samotn\u00e1 lekcia je iba jednoduch\u00fd text, podobn\u00fd tomuto, ktor\u00fd pr\u00e1ve \u010d\u00edta\u0161. Sna\u017e\u00edm sa, aby bol dobre \u010dlenen\u00fd (t.j. aby mal rozumn\u00fa \u0161trukt\u00faru a rozumn\u00e9 nadpisy) a \u013eahko \u010ditate\u013en\u00fd. Ob\u010das mo\u017eno prid\u00e1m nejak\u00fd obr\u00e1zok. A samozrejme, bud\u00fa tu aj kusy k\u00f3du (\u010di\u017ee programu). To bude vyzera\u0165 zhruba takto: Java 1 2 3 4 5 6 7 8 9 10 11 static AfisClient client = null ; public static void main ( String [] args ) throws IOException { // MQ client configuration initialization MQClientConfiguration config = MQClientConfiguration . load ( new File ( client.properties )); // Creation of an AfisClient client = new AfisClientFactory ( config ). createClient (); } C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static AfisClient client = null ; public static void main () { // MQ client configuration initialization MQClientConfiguration config = MQClientConfiguration . load ( File . ReadAllBytes ( client.properties )); // Creation of an AfisClient client = new AfisClientFactory ( config ). createClient (); // Ping queue client . PingApplicantQueue (); } Pevne ver\u00edm, \u017ee sa Ti to bude p\u00e1\u010di\u0165, a \u017ee sa nie\u010do nau\u010d\u00ed\u0161.","title":"\u00davod"},{"location":"#matusova-skola-programovania","text":"","title":"Mat\u00fa\u0161ova \u0161kola programovania"},{"location":"#vitaj-matusko","text":"Prostredn\u00edctvom t\u00fdchto str\u00e1nok by som Ti chcel pom\u00f4c\u0165 nau\u010di\u0165 sa programova\u0165. Z\u00e1merne som si vybral tento sp\u00f4sob, preto\u017ee umo\u017e\u0148uje postupne prid\u00e1va\u0165 nov\u00e9 lekcie, pr\u00edklady sa daj\u00fa uk\u00e1za\u0165 vo viacer\u00fdch programovac\u00edch jazykoch, umo\u017e\u0148uje aj in\u00fdm osob\u00e1m (napr. Jo\u017ekovi) prid\u00e1va\u0165 nov\u00e9 materi\u00e1ly (alebo opravova\u0165 star\u00e9 chyby) ...ktovie \u010do v\u0161etko e\u0161te...","title":"Vitaj Mat\u00fa\u0161ko!"},{"location":"#ako-sa-tu-orientovat","text":"Jednoducho! V\u013eavo je jednoduch\u00e9 naviga\u010dn\u00e9 menu. M\u00f4\u017ee\u0161 ho vn\u00edma\u0165 ako odkazy na jednotliv\u00e9 lekcie. Samotn\u00e1 lekcia je iba jednoduch\u00fd text, podobn\u00fd tomuto, ktor\u00fd pr\u00e1ve \u010d\u00edta\u0161. Sna\u017e\u00edm sa, aby bol dobre \u010dlenen\u00fd (t.j. aby mal rozumn\u00fa \u0161trukt\u00faru a rozumn\u00e9 nadpisy) a \u013eahko \u010ditate\u013en\u00fd. Ob\u010das mo\u017eno prid\u00e1m nejak\u00fd obr\u00e1zok. A samozrejme, bud\u00fa tu aj kusy k\u00f3du (\u010di\u017ee programu). To bude vyzera\u0165 zhruba takto: Java 1 2 3 4 5 6 7 8 9 10 11 static AfisClient client = null ; public static void main ( String [] args ) throws IOException { // MQ client configuration initialization MQClientConfiguration config = MQClientConfiguration . load ( new File ( client.properties )); // Creation of an AfisClient client = new AfisClientFactory ( config ). createClient (); } C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static AfisClient client = null ; public static void main () { // MQ client configuration initialization MQClientConfiguration config = MQClientConfiguration . load ( File . ReadAllBytes ( client.properties )); // Creation of an AfisClient client = new AfisClientFactory ( config ). createClient (); // Ping queue client . PingApplicantQueue (); } Pevne ver\u00edm, \u017ee sa Ti to bude p\u00e1\u010di\u0165, a \u017ee sa nie\u010do nau\u010d\u00ed\u0161.","title":"Ako sa tu orientova\u0165?"},{"location":"files/","text":"Vzh\u013ead zdrojov\u00fdch s\u00faborov Kr\u00e1tky \u00favod o programovac\u00edch jazykoch Existuje ve\u013ea programovac\u00edch jazykov. D\u00f4vodov, pre\u010do ich existuje ve\u013ea, a pre\u010do vlastne st\u00e1le vznikaj\u00fa nov\u00e9 jazyky je viac. Spomeniem niektor\u00e9: niektor\u00e9 jazyky pou\u017e\u00edvaj\u00fa jednoduch\u0161iu syntax (jednoduch\u0161\u00ed jazyk), in\u00e9 zlo\u017eitej\u0161iu syntax, programy nap\u00edsan\u00e9 v niektor\u00fdch jazykoch m\u00f4\u017eu by\u0165 r\u00fdchlej\u0161ie ako v in\u00fdch, niektor\u00e9 programovacie jazyky s\u00fa ur\u010den\u00e9 pre konkr\u00e9tnu oblas\u0165, napr.: v niektor\u00fdch jazykoch sa \u013eah\u0161ie p\u00ed\u0161u webov\u00e9 aplik\u00e1cie (tak\u00e9 aplik\u00e1cie, ktor\u00e9 generuj\u00fa str\u00e1nky) v in\u00fdch jazykoch sa napr. m\u00f4\u017ee jednoduch\u0161ie programova\u0165 mobiln\u00e1 aplik\u00e1cia (dokonca pre Android sa mus\u00ed p\u00edsa\u0165 v podstate v Jave) niektor\u00e9 programovacie jazyky, pou\u017e\u00edvaj\u00fa tzv. funckie, in\u00e9 pou\u017e\u00edvaj\u00fa tzv. objekty programy v niektor\u00fdch jazykoch treba tzv. kompilova\u0165, aby mohli by\u0165 spusten\u00e9, ale v in\u00fdch jazykoch to nemus\u00ed by\u0165 potrebn\u00e9 at\u010f. Zdrojov\u00e9 s\u00fabory Ka\u017ed\u00fd program m\u00e1 svoj zdrojov\u00fd k\u00f3d. Zdrojov\u00fd k\u00f3d programu je niekedy iba v jednom s\u00fabore, ale omnoho \u010dastej\u0161ie je t\u00fdch s\u00faborov viac. V program\u00e1torsk\u00fdch s\u00fa\u0165a\u017eiach, tak\u00fdch, na ktor\u00e9 chod\u00ed Jo\u017eko, sa oby\u010dajne cel\u00fd program zap\u00ed\u0161e iba do jedn\u00e9ho s\u00faboru. Ale be\u017en\u00e9 programy a hry m\u00f4\u017eu pozost\u00e1va\u0165 niekedy aj z tis\u00edcov s\u00faborov. Rozdelenie do mnoh\u00fdch s\u00faborov je praktick\u00e9: krat\u0161ie s\u00fabory sa \u013eah\u0161ie \u010d\u00edtaj\u00fa, program sa oby\u010dajne \u010dlen\u00ed pod\u013ea r\u00f4znych oblast\u00ed, ktor\u00e9 m\u00e1 na starosti: napr. v programe Spotify by sa jeden s\u00fabor mohol venova\u0165 prehr\u00e1vaniu piesne, in\u00fd s\u00fabor vyh\u013ead\u00e1vaniu, at\u010f., v\u010faka mnoh\u00fdm s\u00faborom, m\u00f4\u017eu \u013eah\u0161ie spolupracova\u0165 mnoh\u00ed program\u00e1tori, at\u010f. Pre jednotliv\u00e9 programy je navy\u0161e d\u00f4le\u017eit\u00fd aj n\u00e1zov a koncovka dan\u00e9ho s\u00faboru. Zdroj\u00e1ky pre: programovac\u00ed jazyk Java bud\u00fa vyzera\u0165 Piesen.java , Vyhladavac.java , atd. jazyk C++ : piesen.cpp , program.cpp , atd. Ruby : migrator.rb , atd. Zdroj\u00e1k v Java Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Takto sa pise komentar // Vacsina zdrojakov je vlozena do nejakeho podadresara, // aby sa v tom dalo lahsie hladat. // Preto treba uviest package package com.silake.prvyprogram // Java je tzv. objektovo-orientovany jazyk a preto sa tu programy pisu do // tzv. tried (class) a objectov. // Ako priklad uvadzam class Piesen class Piesen { // Vnutri v classe, je potom mnoho funkcii (hovori sa im aj metody ) public void hraj ( int pocet_minut ) { // Tuto je naprogramovane nieco na zahratie piesne } public void pauzni () { // Tuto je naprogramovane nieco na pauznutie piesne } public int dlzka () { // Tuto je naprogramovane nieco na vratenie dlzky piesne } } Zdroj\u00e1k v C++","title":"Vzh\u013ead zdrojov\u00fdch s\u00faborov"},{"location":"files/#vzhlad-zdrojovych-suborov","text":"","title":"Vzh\u013ead zdrojov\u00fdch s\u00faborov"},{"location":"files/#kratky-uvod-o-programovacich-jazykoch","text":"Existuje ve\u013ea programovac\u00edch jazykov. D\u00f4vodov, pre\u010do ich existuje ve\u013ea, a pre\u010do vlastne st\u00e1le vznikaj\u00fa nov\u00e9 jazyky je viac. Spomeniem niektor\u00e9: niektor\u00e9 jazyky pou\u017e\u00edvaj\u00fa jednoduch\u0161iu syntax (jednoduch\u0161\u00ed jazyk), in\u00e9 zlo\u017eitej\u0161iu syntax, programy nap\u00edsan\u00e9 v niektor\u00fdch jazykoch m\u00f4\u017eu by\u0165 r\u00fdchlej\u0161ie ako v in\u00fdch, niektor\u00e9 programovacie jazyky s\u00fa ur\u010den\u00e9 pre konkr\u00e9tnu oblas\u0165, napr.: v niektor\u00fdch jazykoch sa \u013eah\u0161ie p\u00ed\u0161u webov\u00e9 aplik\u00e1cie (tak\u00e9 aplik\u00e1cie, ktor\u00e9 generuj\u00fa str\u00e1nky) v in\u00fdch jazykoch sa napr. m\u00f4\u017ee jednoduch\u0161ie programova\u0165 mobiln\u00e1 aplik\u00e1cia (dokonca pre Android sa mus\u00ed p\u00edsa\u0165 v podstate v Jave) niektor\u00e9 programovacie jazyky, pou\u017e\u00edvaj\u00fa tzv. funckie, in\u00e9 pou\u017e\u00edvaj\u00fa tzv. objekty programy v niektor\u00fdch jazykoch treba tzv. kompilova\u0165, aby mohli by\u0165 spusten\u00e9, ale v in\u00fdch jazykoch to nemus\u00ed by\u0165 potrebn\u00e9 at\u010f.","title":"Kr\u00e1tky \u00favod o programovac\u00edch jazykoch"},{"location":"files/#zdrojove-subory","text":"Ka\u017ed\u00fd program m\u00e1 svoj zdrojov\u00fd k\u00f3d. Zdrojov\u00fd k\u00f3d programu je niekedy iba v jednom s\u00fabore, ale omnoho \u010dastej\u0161ie je t\u00fdch s\u00faborov viac. V program\u00e1torsk\u00fdch s\u00fa\u0165a\u017eiach, tak\u00fdch, na ktor\u00e9 chod\u00ed Jo\u017eko, sa oby\u010dajne cel\u00fd program zap\u00ed\u0161e iba do jedn\u00e9ho s\u00faboru. Ale be\u017en\u00e9 programy a hry m\u00f4\u017eu pozost\u00e1va\u0165 niekedy aj z tis\u00edcov s\u00faborov. Rozdelenie do mnoh\u00fdch s\u00faborov je praktick\u00e9: krat\u0161ie s\u00fabory sa \u013eah\u0161ie \u010d\u00edtaj\u00fa, program sa oby\u010dajne \u010dlen\u00ed pod\u013ea r\u00f4znych oblast\u00ed, ktor\u00e9 m\u00e1 na starosti: napr. v programe Spotify by sa jeden s\u00fabor mohol venova\u0165 prehr\u00e1vaniu piesne, in\u00fd s\u00fabor vyh\u013ead\u00e1vaniu, at\u010f., v\u010faka mnoh\u00fdm s\u00faborom, m\u00f4\u017eu \u013eah\u0161ie spolupracova\u0165 mnoh\u00ed program\u00e1tori, at\u010f. Pre jednotliv\u00e9 programy je navy\u0161e d\u00f4le\u017eit\u00fd aj n\u00e1zov a koncovka dan\u00e9ho s\u00faboru. Zdroj\u00e1ky pre: programovac\u00ed jazyk Java bud\u00fa vyzera\u0165 Piesen.java , Vyhladavac.java , atd. jazyk C++ : piesen.cpp , program.cpp , atd. Ruby : migrator.rb , atd.","title":"Zdrojov\u00e9 s\u00fabory"},{"location":"files/#zdrojak-v-java","text":"Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Takto sa pise komentar // Vacsina zdrojakov je vlozena do nejakeho podadresara, // aby sa v tom dalo lahsie hladat. // Preto treba uviest package package com.silake.prvyprogram // Java je tzv. objektovo-orientovany jazyk a preto sa tu programy pisu do // tzv. tried (class) a objectov. // Ako priklad uvadzam class Piesen class Piesen { // Vnutri v classe, je potom mnoho funkcii (hovori sa im aj metody ) public void hraj ( int pocet_minut ) { // Tuto je naprogramovane nieco na zahratie piesne } public void pauzni () { // Tuto je naprogramovane nieco na pauznutie piesne } public int dlzka () { // Tuto je naprogramovane nieco na vratenie dlzky piesne } }","title":"Zdroj\u00e1k v Java"},{"location":"files/#zdrojak-v-c","text":"","title":"Zdroj\u00e1k v C++"},{"location":"testovac/","text":"Testova\u010d KSP Existuje str\u00e1nka, na ktorej existuje ve\u013ea \u00faloh pre za\u010d\u00ednaj\u00facich program\u00e1torov ako si ty. Vol\u00e1 sa to Testova\u010d KSP a n\u00e1jde\u0161 to tu: http://testovac.ksp.sk Prihl\u00e1senie Ako prv\u00e9 si vytvor konto a prihl\u00e1s sa. \u00dalohy V sekcii \u00dalohy je mno\u017estvo \u00faloh najr\u00f4znej\u0161\u00edch obtia\u017enost\u00ed. Odpor\u00fa\u010dam prv\u00fa rozsiahlu kateg\u00f3riu \u00davod do programovania . \u00dalohy tam s\u00fa zoraden\u00e9 zhruba pod\u013ea obtia\u017enosti, tak\u017ee k\u013eudne rie\u0161 postupne. Postupom \u010dasu v\u0161ak bude\u0161 potrebova\u0165 nov\u00e9 poznatky - premenn\u00e9, cykly, podmienky, ... Testovanie rie\u0161en\u00ed Nak\u00f3dil si rie\u0161enie \u00falohy a mysl\u00ed\u0161 si, \u017ee to m\u00e1\u0161 \u00faplne spr\u00e1vne? Na Testova\u010di KSP si m\u00f4\u017ee\u0161 da\u0165 svoje rie\u0161enie otestova\u0165. Pod zadan\u00edm \u00falohy sa v\u017edy nach\u00e1dza mo\u017enos\u0165 vlo\u017ei\u0165 tvoj s\u00fabor s rie\u0161en\u00edm a n\u00e1sledne ho odovzda\u0165. V priebehu p\u00e1r sek\u00fand sa ti rie\u0161enie otestuje a dozvie\u0161 sa \u010di si to mal dobre. Testova\u010d ti v\u017edy vr\u00e1ti spr\u00e1vu o tom ako tvoj program dopadol. V\u00fdznam jednotliv\u00fdch spr\u00e1v si m\u00f4\u017ee\u0161 pre\u010d\u00edta\u0165 tu: https://testovac.ksp.sk/wiki/odpovede-testovaca/ Testova\u010d si pam\u00e4t\u00e1 aj rie\u0161enia, ktor\u00e9 si submitol (odovzdal) v minulosti. Zoznam od najmlad\u0161\u00edch k najstar\u0161\u00edm n\u00e1jde\u0161 tie\u017e v detaile \u00falohy. Testova\u010d tvoj program testuje takto: Priprav\u00ed nieko\u013eko vstupov, n\u00e1sledne spust\u00ed tvoj program pre ka\u017ed\u00fd z nich a pozrie sa \u010di dal tvoj program dostato\u010dne r\u00fdchlo, bez probl\u00e9mov spr\u00e1vny v\u00fdstup. Napr\u00edklad v druhej \u00falohe \u010c\u00edslo by mohol ma\u0165 nachystan\u00e9 vstupy s \u010d\u00edslami 3, 987654 a 3727484756. Pre ka\u017ed\u00fd z t\u00fdchto vstupov by spustil tvoj program a pozrel sa \u010di na v\u00fdstup vyp\u00edsal presne 3, 987654, resp. 3727484756. Pri submitoch pozor Treba si d\u00e1va\u0165 pozor na viacero vec\u00ed. Tu s\u00fa naj\u010dastej\u0161ie chyby aj s dovetkom. Pred class nesmie by\u0165 nap\u00edsan\u00e9 public . K\u00f3d sa nesmie nach\u00e1dza\u0165 v \u017eiadnom package . Na\u010d\u00edtavaj a vypisuj v\u0161etko presne tak, ako je to v zadan\u00ed \u0161pecifikovan\u00e9. Ak m\u00e1\u0161 vyp\u00edsa\u0165 Jozko je uzasny , nevyp\u00ed\u0161 Jo\u017eko je kr\u00e1sny ani Jozko je uzas ny (hoci obe s\u00fa pravda). Pozor na medzery, tabul\u00e1tor a osobitne pozor na koniec riadka. Koniec riadku znamen\u00e1, \u017ee ke\u010f po \u0148om za\u010dne\u0161 znova nie\u010do vypisova\u0165, tak u\u017e \u010fal\u0161ie, \u010do nap\u00ed\u0161e\u0161 nebude v tom istom riadku ako predch\u00e1dzaj\u00faci re\u0165azec. Bude to u\u017e v \u010fal\u0161om riadku. Ke\u010f nap\u00ed\u0161e\u0161 System.out.println( Jozko je kral! ); , automaticky sa nap\u00ed\u0161e Jozko je kral a za t\u00fdm koniec riadku. Ke\u010f na nap\u00ed\u0161e\u0161 System.out.print( Jozko je kral! ); , automaticky sa nap\u00ed\u0161e Jozko je kral a za t\u00fdm nebude koniec riadku. Koniec riadku sa zvykne ozna\u010dova\u0165 ako \\n . Pr\u00edklad Dobr\u00fd k\u00f3d, ktor\u00fd vyp\u00ed\u0161e v prvom riadku 47 83\\n a v druhom 64 64 64\\n vyzer\u00e1 napr\u00edklad takto: Java 1 2 3 4 5 6 7 8 9 import java.io.* ; import java.util.* ; class Program { public static void main ( String args []) { System . out . print ( 47 83\\n ); System . out . println ( 64 64 64 ); } } Tak makaj rie\u0161i\u0165!","title":"Testova\u010d"},{"location":"testovac/#testovac-ksp","text":"Existuje str\u00e1nka, na ktorej existuje ve\u013ea \u00faloh pre za\u010d\u00ednaj\u00facich program\u00e1torov ako si ty. Vol\u00e1 sa to Testova\u010d KSP a n\u00e1jde\u0161 to tu: http://testovac.ksp.sk","title":"Testova\u010d KSP"},{"location":"testovac/#prihlasenie","text":"Ako prv\u00e9 si vytvor konto a prihl\u00e1s sa.","title":"Prihl\u00e1senie"},{"location":"testovac/#ulohy","text":"V sekcii \u00dalohy je mno\u017estvo \u00faloh najr\u00f4znej\u0161\u00edch obtia\u017enost\u00ed. Odpor\u00fa\u010dam prv\u00fa rozsiahlu kateg\u00f3riu \u00davod do programovania . \u00dalohy tam s\u00fa zoraden\u00e9 zhruba pod\u013ea obtia\u017enosti, tak\u017ee k\u013eudne rie\u0161 postupne. Postupom \u010dasu v\u0161ak bude\u0161 potrebova\u0165 nov\u00e9 poznatky - premenn\u00e9, cykly, podmienky, ...","title":"\u00dalohy"},{"location":"testovac/#testovanie-rieseni","text":"Nak\u00f3dil si rie\u0161enie \u00falohy a mysl\u00ed\u0161 si, \u017ee to m\u00e1\u0161 \u00faplne spr\u00e1vne? Na Testova\u010di KSP si m\u00f4\u017ee\u0161 da\u0165 svoje rie\u0161enie otestova\u0165. Pod zadan\u00edm \u00falohy sa v\u017edy nach\u00e1dza mo\u017enos\u0165 vlo\u017ei\u0165 tvoj s\u00fabor s rie\u0161en\u00edm a n\u00e1sledne ho odovzda\u0165. V priebehu p\u00e1r sek\u00fand sa ti rie\u0161enie otestuje a dozvie\u0161 sa \u010di si to mal dobre. Testova\u010d ti v\u017edy vr\u00e1ti spr\u00e1vu o tom ako tvoj program dopadol. V\u00fdznam jednotliv\u00fdch spr\u00e1v si m\u00f4\u017ee\u0161 pre\u010d\u00edta\u0165 tu: https://testovac.ksp.sk/wiki/odpovede-testovaca/ Testova\u010d si pam\u00e4t\u00e1 aj rie\u0161enia, ktor\u00e9 si submitol (odovzdal) v minulosti. Zoznam od najmlad\u0161\u00edch k najstar\u0161\u00edm n\u00e1jde\u0161 tie\u017e v detaile \u00falohy. Testova\u010d tvoj program testuje takto: Priprav\u00ed nieko\u013eko vstupov, n\u00e1sledne spust\u00ed tvoj program pre ka\u017ed\u00fd z nich a pozrie sa \u010di dal tvoj program dostato\u010dne r\u00fdchlo, bez probl\u00e9mov spr\u00e1vny v\u00fdstup. Napr\u00edklad v druhej \u00falohe \u010c\u00edslo by mohol ma\u0165 nachystan\u00e9 vstupy s \u010d\u00edslami 3, 987654 a 3727484756. Pre ka\u017ed\u00fd z t\u00fdchto vstupov by spustil tvoj program a pozrel sa \u010di na v\u00fdstup vyp\u00edsal presne 3, 987654, resp. 3727484756.","title":"Testovanie rie\u0161en\u00ed"},{"location":"testovac/#pri-submitoch-pozor","text":"Treba si d\u00e1va\u0165 pozor na viacero vec\u00ed. Tu s\u00fa naj\u010dastej\u0161ie chyby aj s dovetkom. Pred class nesmie by\u0165 nap\u00edsan\u00e9 public . K\u00f3d sa nesmie nach\u00e1dza\u0165 v \u017eiadnom package . Na\u010d\u00edtavaj a vypisuj v\u0161etko presne tak, ako je to v zadan\u00ed \u0161pecifikovan\u00e9. Ak m\u00e1\u0161 vyp\u00edsa\u0165 Jozko je uzasny , nevyp\u00ed\u0161 Jo\u017eko je kr\u00e1sny ani Jozko je uzas ny (hoci obe s\u00fa pravda). Pozor na medzery, tabul\u00e1tor a osobitne pozor na koniec riadka. Koniec riadku znamen\u00e1, \u017ee ke\u010f po \u0148om za\u010dne\u0161 znova nie\u010do vypisova\u0165, tak u\u017e \u010fal\u0161ie, \u010do nap\u00ed\u0161e\u0161 nebude v tom istom riadku ako predch\u00e1dzaj\u00faci re\u0165azec. Bude to u\u017e v \u010fal\u0161om riadku. Ke\u010f nap\u00ed\u0161e\u0161 System.out.println( Jozko je kral! ); , automaticky sa nap\u00ed\u0161e Jozko je kral a za t\u00fdm koniec riadku. Ke\u010f na nap\u00ed\u0161e\u0161 System.out.print( Jozko je kral! ); , automaticky sa nap\u00ed\u0161e Jozko je kral a za t\u00fdm nebude koniec riadku. Koniec riadku sa zvykne ozna\u010dova\u0165 ako \\n .","title":"Pri submitoch pozor"},{"location":"testovac/#priklad","text":"Dobr\u00fd k\u00f3d, ktor\u00fd vyp\u00ed\u0161e v prvom riadku 47 83\\n a v druhom 64 64 64\\n vyzer\u00e1 napr\u00edklad takto: Java 1 2 3 4 5 6 7 8 9 import java.io.* ; import java.util.* ; class Program { public static void main ( String args []) { System . out . print ( 47 83\\n ); System . out . println ( 64 64 64 ); } } Tak makaj rie\u0161i\u0165!","title":"Pr\u00edklad"},{"location":"vstup_vystup/","text":"Vstup a v\u00fdstup Programy, ktor\u00e9 bude\u0161 na za\u010diatku programova\u0165 pou\u017e\u00edvaj\u00fa na komunik\u00e1ciu tzv. \u0161tandardn\u00fd vstup a v\u00fdstup. Na\u010d\u00edtavanie vstupu Na\u010d\u00edtavanie je celkom jednoduch\u00e9. Hore, nad v\u0161etk\u00fdm na\u010d\u00edtavan\u00edm treba vlo\u017ei\u0165 riadok Scanner reader = new Scanner(System.in); . Scanner nemus\u00ed\u0161 pomenova\u0165 reader , m\u00f4\u017ee\u0161 zvoli\u0165 aj in\u00e9 meno. Nakonci, \u00faplne po v\u0161etkom na\u010d\u00edtavan\u00ed treba vlo\u017ei\u0165 riadok reader.close(); . Samotn\u00e9 na\u010d\u00edtavanie je jednoduch\u00e9. Ak chce\u0161 na\u010d\u00edta\u0165 int , nap\u00ed\u0161e\u0161 int vstup = reader.nextInt() . Ak chce\u0161 na\u010d\u00edta\u0165 String , nap\u00ed\u0161e\u0161 int vstup = reader.next() . Pre jednotliv\u00e9 typy n\u00e1jde\u0161 sp\u00f4sob na\u010d\u00edtavania v tejto tabu\u013eke. Typ premennej Ako na\u010d\u00edta\u0165? int int vstup = reader.nextInt(); long long vstup = reader.nextLong(); boolean boolean vstup = reader.nextBoolean(); String String vstup = reader.next(); char String retazec = reader.next(); for(int i = 0; i retazec.size(); i++) { //tu mame i-ty znak vstupu char vstup = retazec[i]; } Niekedy nevie\u0161 ko\u013eko vec\u00ed m\u00e1\u0161 na vstupe a chce\u0161 na\u010d\u00edt\u00e1va\u0165 dok\u00fdm je nie\u010do na vstupe. Tento pr\u00edklad ukazuje ako to urobi\u0165 ak na\u010d\u00edtavame takto stringy: Java 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.io.* ; import java.util.* ; class Vec { public static void main ( String args []) { Scanner reader = new Scanner ( System . in ); //pokia\u013e je na vstupe String while ( reader . hasNext ()) { String vstup = reader . next (); System . out . println ( vstup ); } } } Ak by si chcel na\u010d\u00edtava\u0165 int , spravilo by sa to pomocou reader.hasNextInt() . Podobne pre ostatn\u00e9 typy. Java del\u00ed vstup na \u00faseky medzi tzv. bielymi znakmi (medzera, koniec riadku, tabul\u00e1tor). To znamen\u00e1, \u017ee vstup Peter Jozo Fero rozdel\u00ed na tri Peter , Jozo a Fero . Tamten vstup by sa teda nedal na\u010d\u00edta\u0165 do 1 Stringu. Musel by si pou\u017ei\u0165 3, pre ka\u017ed\u00fd \u00fasek 1. Vypisovanie v\u00fdstupu Na vypisovanie v\u00fdstupu s\u00fa dva pr\u00edkazy System.out.print() a System.out.println() . Do vn\u00fatra z\u00e1tvoriek nap\u00ed\u0161e\u0161, \u010do chce\u0161 vyp\u00edsa\u0165. M\u00f4\u017ee to by\u0165 \u010d\u00edslo (napr. 98 ), re\u0165azec(napr. Chelsea je kr\u00e1sna ) alebo premenn\u00e1. Ned\u00e1 sa to v\u0161ak kombinova\u0165. Jedin\u00fdm pr\u00edkazom sa ned\u00e1 vyp\u00edsa\u0165 napr\u00edklad aj \u010d\u00edslo aj premenn\u00e1. Musel by si pou\u017ei\u0165 jeden pr\u00edkaz, ktor\u00fd vyp\u00ed\u0161e iba \u010d\u00edslo a druh\u00fd, ktor\u00fd vyp\u00ed\u0161e iba premenn\u00fa. System.out.print() nevypisuje koniec riadka, System.out.println() vypisuje koniec riadka. To je ich jedin\u00fd rozdiel. Teoreticky sa teda ka\u017ed\u00e9 System.out.println(...); d\u00e1 nahradi\u0165 za System.out.print(...); System.out.print(\\n) . Pr\u00edklad Cel\u00e9 to m\u00f4\u017ee vyzera\u0165 nejako takto. Spust\u00ed sa program. Program vyp\u00ed\u0161e Zadajte svoje meno: Pou\u017e\u00edvate\u013e (ja, ty, oco alebo k\u013eudne aj dedko) nap\u00ed\u0161e svoje meno, napr. Fero . Program toto meno (nech je ak\u00e9ko\u013evek) na\u010d\u00edta a nejako spracuje. Program vyp\u00ed\u0161e Zadajte svoj po\u010det r\u00fak! . Pou\u017e\u00edvate\u013e (povedzme ja) nap\u00ed\u0161e 2 . Program si op\u00e4\u0165 na\u010d\u00edta toto \u010d\u00edslo, vypo\u010d\u00edta, ko\u013eko r\u00fak mu ch\u00fdba a toto \u010d\u00edslo vyp\u00ed\u0161e. Implement\u00e1cia: Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.io.* ; import java.util.* ; class Vec { public static void main ( String args []) { //vy\u017eiadame si u\u017e\u00edvate\u013eovo meno System . out . print ( Zadajte svoje meno: ); //ideme na\u010d\u00edtava\u0165, najprv treba vytvori\u0165 Scanner Scanner reader = new Scanner ( System . in ); //na\u010d\u00edtame do premennej meno u\u017e\u00edvate\u013ea String meno = reader . next (); //vy\u017eiadame pocet ruk System . out . print ( Zadajte svoj po\u010det r\u00fak: ); //na\u010d\u00edtame do premennej pocet ruk int pocet_ruk = reader . nextInt (); int chyba_ruk = 2 - pocet_ruk ; //vypiseme pocet chybajucich ruk System . out . print ( Chyba Vam ); System . out . print ( chyba_ruk ); System . out . print ( ruk\\n ); } }","title":"Vstup a v\u00fdstup"},{"location":"vstup_vystup/#vstup-a-vystup","text":"Programy, ktor\u00e9 bude\u0161 na za\u010diatku programova\u0165 pou\u017e\u00edvaj\u00fa na komunik\u00e1ciu tzv. \u0161tandardn\u00fd vstup a v\u00fdstup.","title":"Vstup a v\u00fdstup"},{"location":"vstup_vystup/#nacitavanie-vstupu","text":"Na\u010d\u00edtavanie je celkom jednoduch\u00e9. Hore, nad v\u0161etk\u00fdm na\u010d\u00edtavan\u00edm treba vlo\u017ei\u0165 riadok Scanner reader = new Scanner(System.in); . Scanner nemus\u00ed\u0161 pomenova\u0165 reader , m\u00f4\u017ee\u0161 zvoli\u0165 aj in\u00e9 meno. Nakonci, \u00faplne po v\u0161etkom na\u010d\u00edtavan\u00ed treba vlo\u017ei\u0165 riadok reader.close(); . Samotn\u00e9 na\u010d\u00edtavanie je jednoduch\u00e9. Ak chce\u0161 na\u010d\u00edta\u0165 int , nap\u00ed\u0161e\u0161 int vstup = reader.nextInt() . Ak chce\u0161 na\u010d\u00edta\u0165 String , nap\u00ed\u0161e\u0161 int vstup = reader.next() . Pre jednotliv\u00e9 typy n\u00e1jde\u0161 sp\u00f4sob na\u010d\u00edtavania v tejto tabu\u013eke. Typ premennej Ako na\u010d\u00edta\u0165? int int vstup = reader.nextInt(); long long vstup = reader.nextLong(); boolean boolean vstup = reader.nextBoolean(); String String vstup = reader.next(); char String retazec = reader.next(); for(int i = 0; i retazec.size(); i++) { //tu mame i-ty znak vstupu char vstup = retazec[i]; } Niekedy nevie\u0161 ko\u013eko vec\u00ed m\u00e1\u0161 na vstupe a chce\u0161 na\u010d\u00edt\u00e1va\u0165 dok\u00fdm je nie\u010do na vstupe. Tento pr\u00edklad ukazuje ako to urobi\u0165 ak na\u010d\u00edtavame takto stringy: Java 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.io.* ; import java.util.* ; class Vec { public static void main ( String args []) { Scanner reader = new Scanner ( System . in ); //pokia\u013e je na vstupe String while ( reader . hasNext ()) { String vstup = reader . next (); System . out . println ( vstup ); } } } Ak by si chcel na\u010d\u00edtava\u0165 int , spravilo by sa to pomocou reader.hasNextInt() . Podobne pre ostatn\u00e9 typy. Java del\u00ed vstup na \u00faseky medzi tzv. bielymi znakmi (medzera, koniec riadku, tabul\u00e1tor). To znamen\u00e1, \u017ee vstup Peter Jozo Fero rozdel\u00ed na tri Peter , Jozo a Fero . Tamten vstup by sa teda nedal na\u010d\u00edta\u0165 do 1 Stringu. Musel by si pou\u017ei\u0165 3, pre ka\u017ed\u00fd \u00fasek 1.","title":"Na\u010d\u00edtavanie vstupu"},{"location":"vstup_vystup/#vypisovanie-vystupu","text":"Na vypisovanie v\u00fdstupu s\u00fa dva pr\u00edkazy System.out.print() a System.out.println() . Do vn\u00fatra z\u00e1tvoriek nap\u00ed\u0161e\u0161, \u010do chce\u0161 vyp\u00edsa\u0165. M\u00f4\u017ee to by\u0165 \u010d\u00edslo (napr. 98 ), re\u0165azec(napr. Chelsea je kr\u00e1sna ) alebo premenn\u00e1. Ned\u00e1 sa to v\u0161ak kombinova\u0165. Jedin\u00fdm pr\u00edkazom sa ned\u00e1 vyp\u00edsa\u0165 napr\u00edklad aj \u010d\u00edslo aj premenn\u00e1. Musel by si pou\u017ei\u0165 jeden pr\u00edkaz, ktor\u00fd vyp\u00ed\u0161e iba \u010d\u00edslo a druh\u00fd, ktor\u00fd vyp\u00ed\u0161e iba premenn\u00fa. System.out.print() nevypisuje koniec riadka, System.out.println() vypisuje koniec riadka. To je ich jedin\u00fd rozdiel. Teoreticky sa teda ka\u017ed\u00e9 System.out.println(...); d\u00e1 nahradi\u0165 za System.out.print(...); System.out.print(\\n) .","title":"Vypisovanie v\u00fdstupu"},{"location":"vstup_vystup/#priklad","text":"Cel\u00e9 to m\u00f4\u017ee vyzera\u0165 nejako takto. Spust\u00ed sa program. Program vyp\u00ed\u0161e Zadajte svoje meno: Pou\u017e\u00edvate\u013e (ja, ty, oco alebo k\u013eudne aj dedko) nap\u00ed\u0161e svoje meno, napr. Fero . Program toto meno (nech je ak\u00e9ko\u013evek) na\u010d\u00edta a nejako spracuje. Program vyp\u00ed\u0161e Zadajte svoj po\u010det r\u00fak! . Pou\u017e\u00edvate\u013e (povedzme ja) nap\u00ed\u0161e 2 . Program si op\u00e4\u0165 na\u010d\u00edta toto \u010d\u00edslo, vypo\u010d\u00edta, ko\u013eko r\u00fak mu ch\u00fdba a toto \u010d\u00edslo vyp\u00ed\u0161e. Implement\u00e1cia: Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.io.* ; import java.util.* ; class Vec { public static void main ( String args []) { //vy\u017eiadame si u\u017e\u00edvate\u013eovo meno System . out . print ( Zadajte svoje meno: ); //ideme na\u010d\u00edtava\u0165, najprv treba vytvori\u0165 Scanner Scanner reader = new Scanner ( System . in ); //na\u010d\u00edtame do premennej meno u\u017e\u00edvate\u013ea String meno = reader . next (); //vy\u017eiadame pocet ruk System . out . print ( Zadajte svoj po\u010det r\u00fak: ); //na\u010d\u00edtame do premennej pocet ruk int pocet_ruk = reader . nextInt (); int chyba_ruk = 2 - pocet_ruk ; //vypiseme pocet chybajucich ruk System . out . print ( Chyba Vam ); System . out . print ( chyba_ruk ); System . out . print ( ruk\\n ); } }","title":"Pr\u00edklad"}]}